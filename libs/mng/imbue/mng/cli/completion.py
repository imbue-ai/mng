import json
import os
import shutil
import subprocess
import time
from pathlib import Path
from typing import Final

import click
from click.shell_completion import CompletionItem

COMPLETION_CACHE_FILENAME: Final[str] = ".completion_cache.json"
CLI_COMPLETIONS_FILENAME: Final[str] = "cli_completions.json"
_BACKGROUND_REFRESH_COOLDOWN_SECONDS: Final[int] = 30


def _get_host_dir() -> Path:
    """Resolve the host directory from MNG_HOST_DIR or the default ~/.mng."""
    env_host_dir = os.environ.get("MNG_HOST_DIR")
    return Path(env_host_dir) if env_host_dir else Path.home() / ".mng"


def _read_agent_names_from_cache() -> list[str]:
    """Read agent names from the completion cache file.

    Reads {host_dir}/.completion_cache.json and returns the "names" list.
    The cache is written by list_agents() in the API layer.

    Returns an empty list if the cache does not exist, is malformed, or any error occurs.
    This function is designed to never raise -- shell completion must not crash.
    """
    try:
        cache_path = _get_host_dir() / COMPLETION_CACHE_FILENAME
        if not cache_path.is_file():
            return []

        data = json.loads(cache_path.read_text())
        names = data.get("names")
        if not isinstance(names, list):
            return []

        return sorted(name for name in names if isinstance(name, str) and name)
    except (json.JSONDecodeError, OSError):
        return []


def _trigger_background_cache_refresh() -> None:
    """Fire-and-forget a background `mng list` to refresh the completion cache.

    Spawns a detached subprocess so shell completion returns immediately.
    Skips the refresh if the cache was updated within the last N seconds
    to avoid excessive subprocess spawning.

    This function never raises -- background refresh failures are silently ignored.
    Logging is intentionally omitted: importing loguru would add import latency to
    every TAB press, and log output on stderr can interfere with shell completion.
    """
    try:
        cache_path = _get_host_dir() / COMPLETION_CACHE_FILENAME
        if cache_path.is_file():
            age = time.time() - cache_path.stat().st_mtime
            if age < _BACKGROUND_REFRESH_COOLDOWN_SECONDS:
                return

        mng_path = shutil.which("mng")
        if mng_path is None:
            return

        # Uses subprocess.Popen directly (not ConcurrencyGroup) because this module
        # runs in the shell completion context and intentionally avoids importing
        # mng internals to keep TAB completion fast and lightweight.
        devnull = subprocess.DEVNULL
        subprocess.Popen(
            [mng_path, "list", "--format", "json", "-q"],
            stdout=devnull,
            stderr=devnull,
            start_new_session=True,
        )
    except OSError:
        # Intentionally silent: importing loguru adds latency to every TAB press,
        # and stderr output can interfere with the shell completion protocol.
        pass


def complete_agent_name(
    ctx: click.Context,
    param: click.Parameter,
    incomplete: str,
) -> list[CompletionItem]:
    """Click shell_complete callback that provides agent name completions."""
    names = _read_agent_names_from_cache()
    _trigger_background_cache_refresh()
    return [CompletionItem(name) for name in names if name.startswith(incomplete)]


# =============================================================================
# Static CLI completions (generated at build time)
# =============================================================================
#
# These functions read from a static JSON file that lists all CLI commands and
# subcommands. The file is generated by scripts/make_cli_docs.py and checked
# into the repo at imbue/mng/resources/cli_completions.json.
#
# This is analogous to the agent name cache above, but for commands: instead of
# discovering commands live by walking the Click command tree, tab completion
# reads from a pre-generated list.


def _get_cli_completions_path() -> Path:
    """Return the path to the static CLI completions resource file.

    Uses MNG_CLI_COMPLETIONS_PATH if set, otherwise falls back to the default
    package resource location.
    """
    env_path = os.environ.get("MNG_CLI_COMPLETIONS_PATH")
    if env_path:
        return Path(env_path)
    return Path(__file__).parent.parent / "resources" / CLI_COMPLETIONS_FILENAME


def _read_cli_completions_file() -> dict | None:
    """Read the static CLI completions file.

    Returns the parsed JSON data, or None if the file does not exist, is
    malformed, or any error occurs. This function is designed to never raise --
    shell completion must not crash.
    """
    try:
        path = _get_cli_completions_path()
        if not path.is_file():
            return None
        data = json.loads(path.read_text())
        if not isinstance(data, dict):
            return None
        return data
    except (json.JSONDecodeError, OSError):
        return None


def read_cached_commands() -> list[str] | None:
    """Read cached top-level command names from the static completions file.

    Returns a sorted list of command names (including aliases), or None if the
    file does not exist or is malformed.
    """
    data = _read_cli_completions_file()
    if data is None:
        return None
    commands = data.get("commands")
    if not isinstance(commands, list):
        return None
    result = [name for name in commands if isinstance(name, str) and name]
    return sorted(result) if result else None


def read_cached_subcommands(command_name: str) -> list[str] | None:
    """Read cached subcommand names for a given parent command.

    Returns a sorted list of subcommand names, or None if the file does not
    exist, is malformed, or the command has no cached subcommands.
    """
    data = _read_cli_completions_file()
    if data is None:
        return None
    subcommand_by_command = data.get("subcommand_by_command")
    if not isinstance(subcommand_by_command, dict):
        return None
    subcommands = subcommand_by_command.get(command_name)
    if not isinstance(subcommands, list):
        return None
    result = [name for name in subcommands if isinstance(name, str) and name]
    return sorted(result) if result else None


class CachedSubcommandCompletionMixin:
    """Mixin for click.Group subclasses that reads subcommand completions from the static cache.

    Subclasses must set `_completion_cache_key` to the command name used as
    the lookup key in cli_completions.json.
    """

    _completion_cache_key: str

    def shell_complete(self, ctx: click.Context, incomplete: str) -> list[CompletionItem]:
        cached = read_cached_subcommands(self._completion_cache_key)
        if cached is not None:
            completions = [CompletionItem(name) for name in cached if name.startswith(incomplete)]
            completions.extend(click.Command.shell_complete(self, ctx, incomplete))  # type: ignore[arg-type]
            return completions
        return super().shell_complete(ctx, incomplete)  # type: ignore[misc]
